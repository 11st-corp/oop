# 함께 모으기

### 개념 관점

> 도메인 안에 존재하는 개념과 개념들 사이의 관계
>

도메인이란, 사용자들이 관심을 가지고 있는 특정 분야나 주제 ‘배경’ 이라는 의미

- 소프트 웨어는 이 도메인의 문제를 해결하기 위해 개발
- 사용자 영역인 도메인의 규칙과 제약을 최대한 반영

**각 객체가 담고 있는 책임을 ‘은유’를 통해 정의한다.**

### 명세 관점

사용자 영역 → 프로그래머 영역

- 객체의 인터페이스에 집중한다.
- 인터페이스와 구현을 분리하여야 하므로 구현에 대해서는 집중하지 않는다.

**각 객체가 ‘무엇’을 할 것인가를 정의한다.**

### 구현 관점

프로그래머 영역 → 코드 영역

- 객체의 책임을 어떻게 구현할 것인가에 집중한다.

**각 객체가 책임을 ‘어떻게’ 수행할 것인가를 정의한다.**

> 클래스는 세가지 관점을 모두 수용할 수 있도록 해야하며, 동시에 세가지 관점을 식별할 수 있도록 개념 - 인터페이스 - 구현을 분리해야한다.
>

객체의 인터페이스 - 객체가 메시지를 수신하는 영역, 책임이 존재하는 영역으로 이는 명세 관점에 대응된다.

## 커피 전문점 도메인

도메인 - 커피 전문점

### 객체 구성

메뉴판 → 객체

- 네 개의 메뉴 항목으로 구성되어있다.
- 메뉴 항목 → 객체

손님 → 객체

- 손님은 ‘메뉴 항목’을 선택하여 바리스타에게 전달.

바리스타 → 객체

- 받은 ‘메뉴 항목’에 따른 커피를 만듦.

제조된 커피 → 객체

### 관계 설정

손님이 주문하기 위해서는 메뉴판을 봐야한다. → 손님 - 메뉴판 간의 ‘관계’가 필요하다는 의미

손님이 주문을 바리스타에게 전달해야한다. → 손님 - 바리스타

바리스타는 커피를 제조해야한다.  → 바리스타 - 제조된 커피

### 타입 추상화

객체로 정의하지 않고 추상화하여 ‘타입’을 사용하여 복잡성을 낮춘다.

- 네개의 ‘메뉴 항목’을 동일한 ‘메뉴 항목 타입’의 네 개의 인스턴스로 본다.

### 타입 간의 관계 설정

메뉴판 타입 - 메뉴 항목 타입

- 메뉴판 타입은 메뉴 항목 타입을 ‘포함’한다. → ‘포함’ 관계 또는 ‘합성’ 관계

메뉴판 타입 - 손님 타입
- 포함 또는 합성 관계가 아니므로 ‘연관’ 관계이다.


**이제부터 협력을 설계하기 위해서 올바른 객체에 올바른 책임을 할당해야한다.**

> **어떤 관계인지는 중요하지 않고, 도메인이 어떤 타입으로 구성되어 있으며 각 타입 간의 어떤 관계가 존재하는지 알아보면서 도메인을 이해하는데에 있다.**
>

## 설계하고 구현하기

훌륭한 협력 → 객체가 메시지를 선택하는 것이 아닌, 메시지가 객체를 선택하게 한다.

**메시지를 선택 → 객체를 선택 → 객체가 메시지를 송신 가능 → 객체에 책임 부여 → 객체 외부 인터페이스에 포함.**

1. **협력을 시작하는 메시지를 선정한다.**
    - 커피를 주문하라
2. **해당 메시지를 수신할 객체를 선택한다.**
    - 도메인에서 책임을 수행할 수 있는 타입을 선택한다.
    - 그 타입의 인스턴스를 통해 해당 메시지를 수신할 수 있는 객체를 사용한다.
    - 커피를 주문하라 → [손님]
        - 이 때, 주문하라는 메시지에 ‘메뉴 이름’이라는 부수 정보가 필요하다.
3. **객체가 스스로 할 수 없는 일이 있다면 메시지를 전송한다.**
    - 커피에 대한 정보가 존재하지 않으므로 메뉴판에 대해 메시지를 전송한다.
    - 커피를 주문하라 → [손님] → 메뉴항목을 찾아라 → [메뉴판]
        - 이 때, 메뉴 항목을 찾아라라는 메시지에 ‘메뉴 이름’이라는 부수 정보가 필요하다.
        - 커피에 대한 정보인 ‘메뉴 항목’이라는 부수정보를 제공받는다.
    - ‘메뉴판’은 메뉴 항목을 찾아라 라는 메시지를 수신할 수 있는 객체이다.
        - 메뉴 항목을 찾아라 라는 메시지에 부수정보인 ‘메뉴 이름’을 통해 ‘메뉴 항목’을 메시지로 전달한다.

4. **1-3을 반복하며 협력의 객체와 메시지를 정의한다.**
    - 커피를 만들어줘라 라는 메시지를 정의한다.
        - ‘메뉴 항목’이라는 부수정보를 전달한다.
    - 해당 메시지를 수신할 ‘바리스타’ 객체를 선택한다.
        - 커피를 만들어줘라 라는 메시지에 부수정보인 ‘메뉴 항목’을 통해 ‘커피’을 메시지로 전달한다.
    - **이 때, 바리스타가 어떻게 만들 것인지에 대해서는 정의하지 않는다. 단순히 메시지(공용 인터페이스)에 집중**
  5. **메시지를 정제하여 각 객체의 인터페이스를 정의한다.**
     > **객체의 메시지가 곧 인터페이스이다.**


    손님
     - operation - ‘커피를 주문하라’
        - 부수정보 - ‘메뉴 이름’
        - 응답 - ‘’

    메뉴판
     - operation - ‘메뉴 항목을 찾아라’
        - 부수정보 - ‘메뉴 이름’
        - 응답 - ‘메뉴 항목’

    바리스타
     - operation - ‘커피를 만들라’
        - 부수정보 - ‘메뉴 항목’
        - 응답 - ‘커피’

6. **구현한다.**
  객체 → 클래스
     operation → public 메서드
     응답 → 반환 타입
     **그럼 operation에서 객체 간의 관계는 어떻게?**

    - 연관 관계라고 한다면 메서드의 인자로
         ```java
        class Customer {
              public void order(String menuName, Menu menu, Barista barista) {}
        }
        ```

    - 포함 관계라고 한다면 내부의 private 프로퍼티로
         ```java
        class Manu {
              private List<MenuItem> items;
        }
        ```


## 코드와 세가지 관점

### 개념 관점

모든 클래스가 ‘커피 전문점’ 도메인을 충분히 설명할 수 있다.

> 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다.
>
- 커피 제조과정을 변경하려면? → 바리스타만 변경하면 된다!

### 명세 관점

클래스의 public 메서드가 곧 인터페이스이다.

> 인터페이스는 수정하기 어렵다는 사실을 명심하자.
>

### 구현 관점

클래스의 내부 구현은 인터페이스와 무관하다. 즉, 구현이 변경된다고해서 외부 인터페이스가 변경되어서는 안된다.

**이 세가지 관점을 모두 드러낼 수 있도록 개발해라!**

### 도메인 개념을 참조하는 이유

객체는 현실을 ‘은유’하기 때문에 도메인을 충분히 반영해야한다. 메시지를 수신할 객체를 이 도메인을 통해서 선택하기 때문이다. 이후에 변경을 하였을 때, 변경할 영역을 도메인을 기반으로 추측하고 객체를 선택하기 때문에 유지보수성에 중요한 영향을 미친다.

### 인터페이스와 구현을 분리하라